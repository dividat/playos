#+TITLE: PlayOS

* Overview
  
A custom Linux system for running Dividat Play.

** Background

[[https://dividat.com/en/products/dividat][Dividat Play]] is a web-based application used in conjunction with the [[https://dividat.com/en/products/dividat][Dividat Senso]] hardware as a game-based training system.

Installations of Dividat Play and Dividat Senso usually receive a dedicated computer to run the software. PlayOS is a custom Linux system for such computers.

PlayOS is a custom [[https://nixos.org/][NixOS]] system that runs Dividat Play in a restricted kiosk environment. Installations can be upgraded atomically over-the-air. Deployed machines have two system partitions (A/B), each containing a complete system. PlayOS is compatible with NixOS modules and packages, everything that is available from upstream NixOS can be used.
  
** Build System

[[https://nixos.org/nix/][Nix]] is used as build system. Running ~nix build~ in the repository root will build all artifacts required to deploy system (via fresh installation or upgrade).

** Testing

*** Virtual Machines

System can be run in a virtual machine. For this the tool ~run-playos-in-vm~ is provided.

With minimal test instrumentation a virtual machine can be started without creating a (virtual) disk. For this a system partition is created on a folder on the host and shared to the virtual machine via [[https://wiki.qemu.org/Documentation/9psetup][9P]]. This allows for rapid development cycles as no images containing the entire system have to be built. However low-level system components (such as bootloader) are bypassed with test instrumentation.

For a more complete test a virtual disk containing all necessary partitions and pre-installed systems can be used.

*** TODO Automated Testing

NixOS has a very cool [[https://nixos.org/nixos/manual/index.html#sec-obtaining][testing framework]] (see also [[https://nixos.org/~eelco/talks/issre-nov-2010.pdf][this presentation]]). It relies on the module <nixos/modules/virtualisation/qemu-vm.nix> and <nixos/modules/testing/test-instrumentation.nix> to set up a efficient virtual machine. 

However ~qemu-vm.nix~ assumes a certain filesystem layout which is incompatible with our ~system-partition~ module. Possible solutions:

- Create our own test machinery (extending ~run-playos-in-vm~).
- Do testing without ~system-partition~ (and other low-level) modules.
- Figure out how to override filesystem assumptions in ~qemu-vm.nix~ and use the NixOS tooling machinery.

Doing testing without low-level modules is not desirable. Those are exactly the things that need to be tested extensively and creating own machinery is unnecessary. We need to figure out how to override assumptions in ~qemu-vm.nix~ and possibly adapt our modules to be testable with existing machinery.

* System
** Disk layout

A PlayOS installation has 4 partitions:

- EFI system partition (ESP): Contains bootloader and persistent system configuration data.
- Data partition: For persistent user data.
- System partition A
- System partition B

** Booting
   
PlayOS can only boot in UEFI mode. [[https://www.gnu.org/software/grub/][GNU Grub]] is used as bootloader.

The bootloader [[*Boot selection logic][chooses system to boot]] (A or B) based on persistent variables (GRUB environment variables on the EFI system partition). 

The bootloader boots the selected system by loading the kernel and initial ram disk from the [[*System partition][system partition]]. The bootloader passes the device the system partition is located on as well as the [[*Update Mechanism][RAUC]] slot as kernel arguments (e.g. ~root=/dev/by-label/system.a rauc.slot=a~).

*** Boot selection logic

The [[*Booting][GRUB]] environment variables ~ORDER~, ~a_TRY~, ~b_TRY~, ~a_OK~ and ~b_OK~ are used to select system to boot:

- ~ORDER~ describes the order in which boots should be attempted (e.g. ~"a b"~).
- ~a_TRY~ and ~b_TRY~ describes the number of attempts to boot the respective systems.
- ~a_OK~ and ~b_OK~ are used to mark systems that are non-bootable.

GRUB attempts to boot the first system in ~ORDER~ which has a value less than 3 in the respecitve ~TRY~ variable and where ~a_OK~ is not equal ~0~. If there are no boot options available GRUB will display a boot selection menu.

See also sections on the [[*Update Mechanism][Update Mechanism]] and [[*Mark system as good][Mark system as good]].

** Init system

After low-level system is initialized from the initial ram disk (Stage 1) the ~/init~ script on the system partition (Stage 2) is run, which will start all necessary services to make system usable.

** System partition

A system partition contains following files:

- ~/kernel~: Linux kernel
- ~/initrd~: Initial ram disk
- ~/init~: Initialization script
- ~/nix/store~: Nix store containing all software and configuration of the system. This is bind mounted to the root file system.

The system partition is mounted on ~/mnt/system~ (read-only).

** Volatile root

A temporary filesystem in volatile memory ([[https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt][tmpfs]]) is used as root. Folders containing persistent user data need to be specified explicitly and are bind mounted to correct locations on root.

** Machine ID
   
Every machine is assigned a [[https://tools.ietf.org/html/rfc4122][Universal Unique IDentifier]] (machine-id) during installation. The machine-id is stored on the ~/boot~ partition and is persisted between [[*Update Mechanism][updates]] and [[*Rescue System][user data wiping]].

The machine-id is set on boot via the ~system.machine_id~ kernel argument and then [[https://www.freedesktop.org/software/systemd/man/machine-id.html][handled by the init system]].

** Dividat Driver

The [[https://github.com/dividat/driver][Dividat Driver]], which handles connectivity between Dividat Play and Dividat Senso hardware, is installed and runs as a system service.

** TODO Kiosk
** TODO PlayOS Controller

The PlayOS Controller is a system daemon handling various system management tasks:

- Management of updates
- Checking system health
- Offering a unified interface for user configuration of certain system parameters

A user interface for configuration is exposed via a HTTP/HTML and is accessible from within the [[*Kiosk][Kiosk]].

Implementation details:

- [[https://ocaml.org/][OCaml]] seems nice a like match, because I like the language, it's easy to do [[https://ocaml.github.io/ocamlunix/ocamlunix.html][Unix system programming]] and there is an nice [[https://github.com/diml/obus][D-Bus Interface]].
  - [[https://ocsigen.org/][Ocsigen/Eliom]]: almost-magic framework for creating client/server applications. I would love to learn this. However build system seems slightly non-standard (not just ~dune~), documentation looks scary, there are hardly any example applications (open-source) and the "5 Minute Quickstart" did not work on NixOS.
  - Combination of an [[https://github.com/rgrinberg/opium][Opium]] (a more approachable OCaml Web framework) application that exposes a Web API that is consumed by a ~js_of_ocaml~ compiled web app. This is not as nice a coupling between server and client as with Ocsigen/Eliom but has the advantage that the API is very clearly defined and consumable by other clients (e.g. a CLI utility) - a big advantage.
- Elixir/Erlang: [[https://phoenixframework.org/][Phoenix]] looks cool. I suspect that the level of abstraction is slightly to high. I anticipate having to do some Unix level things (such as checking kernel arguments or hardware health), which might be not so straigh-forward for a BEAM application.
- Haskell: There are some well established Web frameworks: [[https://www.yesodweb.com/][Yesod]] (seems to be capable of doing everything), [[https://www.spock.li][Spock]] (simpler) or [[https://github.com/scotty-web/scotty][Scotty]] (also simpler). Doing low-level stuff should be doable.

*** TODO Update Mechanism

 The ~poc~ regularly checks for available updates. Updates are distributed as [[https://www.rauc.io/][RAUC]] [[https://rauc.readthedocs.io/en/latest/basic.html#update-artifacts-bundles][bundles]]. If an update is available the bundle is installed by RAUC.

During installation of a new system on slot ~x~ the ~x_OK~ variable is set to ~0~, marking the system non-bootable. After successful installation, [[https://rauc.readthedocs.io/en/latest/reference.html#grub][RAUC sets]] the ~ORDER~ to contain ~x~ as first element and sets the number of tries to 0 (~x_TRY=0~) and marks the system bootable (~x_OK=1~). On next boot GRUB attempts to boot system ~x~ for 3 times before falling back to the next system in ~ORDER~ (see [[*Boot selection logic][boot selection logic]]).

**** TODO How to compare versions

 A system partition can be updated while the other is running. The ~poc~ regularly checks for updates.

**** TODO Bundle verification

RAUC bundles are signed. Before installing an update RAUC will verify signature against keyring installed on system (see [[https://rauc.readthedocs.io/en/latest/advanced.html#security][here]]).

The keyring to be installed on the system must be passed to the build system with the ~keyring~ argument. 

The RAUC bundle produced by the build system is signed by a dummy development/testing key. The bundle needs to be [[https://rauc.readthedocs.io/en/latest/advanced.html#resigning-bundles][resigned]] before it can be deployed. The script ~deploy-playos-update~ automates this process.

**** TODO develop update delivery mechanism
*** TODO Mark system as good

Currently a systemd service is setup to mark the sytem as good. This should be done by the controller after making sure things are running ok.

If system ~x~ is considered to be running satisfactory the system is marked good via RAUC, which resets the number of boot attempts (~x_TRY=0~) and marks the system bootable (~x_OK=1~) (see [[*Boot selection logic][boot selection logic]]).

*** TODO Network configuration
*** TODO Logging Mechanism

Important system events should be logged to ~log.dividat.com~.

** TODO Rescue System

User data wiping (formatting the data partition) is a hassle when the system is already running (users need to be logged out, disk needs to be unmounted and then possibly the system reboots). An easier way of implementing this is to provide a Linux kernel and a minimal initial ram disk on the ESP that can be used to wipe data.

* Installer
  
A bootable image is built that can be used to install systems. The installation is performed by a Python script (~install-playos.py~). It will automatically detect a suitable device to install the system to and ask for confirmation before partitioning, formatting and installing the system. Optionally the script can be used non-interactively.

Reasons for using Python include the [[https://github.com/dcantrell/pyparted][pyparted]] bindings to the [[https://www.gnu.org/software/parted/][GNU parted]] library for partitioning.

** TODO Use rauc bundle during installation

*** [2018-12-07 Fri] Initial experimentation

- Not compressing system tarball with xz increases size of rauc bundle from 180MB to 280MB (no X system).
- Rauc has [[https://rauc.readthedocs.io/en/latest/examples.html#write-slots-without-update-mechanics][write-slot]] option that can write an image to a slot. This still requires rauc to be properly configured on installation system (it needs to know about slots).
- Using Rauc nicely makes the installer script more complicated. Currently not worth the effort.
- Another idea: use rauc bundle but bypass rauc (bundle is just a squashfs image). However crypthographic verification of bundle is also bypassed.

** TODO Check for latest version of bundle over network
** TODO Check for already installed system and preserve [[*Machine ID][machine-id]]
